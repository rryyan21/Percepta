<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overshoot Vision Stream</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .config-section {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        input[type="text"],
        input[type="number"],
        textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: #667eea;
            color: white;
            flex: 1;
        }

        .btn-start:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-stop {
            background: #f56565;
            color: white;
            flex: 1;
        }

        .btn-stop:hover:not(:disabled) {
            background: #e53e3e;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .video-section,
        .results-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h2 {
            color: #333;
            margin-bottom: 16px;
            font-size: 20px;
        }

        video {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }

        .status {
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            font-weight: 500;
        }

        .status.idle {
            background: #e0e0e0;
            color: #666;
        }

        .status.starting {
            background: #fef3c7;
            color: #92400e;
        }

        .status.active {
            background: #d1fae5;
            color: #065f46;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .results {
            max-height: 500px;
            overflow-y: auto;
        }

        .result-item {
            padding: 12px;
            margin-bottom: 12px;
            background: #f9fafb;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }

        .result-number {
            font-weight: 700;
            color: #667eea;
            margin-bottom: 4px;
        }

        .result-text {
            color: #333;
            line-height: 1.6;
        }

        .result-latency {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 16px;
        }

        .stat-item {
            flex: 1;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #667eea;
        }

        .state-info {
            padding: 16px;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            color: white;
        }

        .state-info h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
        }

        .state-info p {
            margin: 4px 0;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>ðŸš€ Overshoot Vision Stream</h1>

            <div class="config-section">
                <label for="apiKey">API Key:</label>
                <input type="text" id="apiKey" placeholder="Enter your Overshoot API key">
            </div>

            <div class="button-group">
                <button class="btn-start" id="startBtn">Start Autonomous Navigation</button>
                <button class="btn-stop" id="stopBtn" disabled>Stop Navigation</button>
            </div>
        </div>

        <div class="content">
            <div class="video-section">
                <h2>ðŸ“¹ Camera Feed</h2>
                <div id="statusDiv" class="status idle">
                    âšª Ready to start
                </div>
                <video id="videoPreview" autoplay muted playsinline></video>
            </div>

            <div class="results-section">
                <h2>ðŸ“Š Navigation Status</h2>

                <!-- State Information Display -->
                <div class="state-info" id="stateInfo">
                    <h3 id="stateTitle">âšª Waiting to Start</h3>
                    <p id="stateTarget">Target: None</p>
                    <p id="stateAction">Action: Idle</p>
                    <p id="statePhase">Phase: None</p>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-label">Current State</div>
                        <div class="stat-value" id="currentStateNum">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Distance (cm)</div>
                        <div class="stat-value" id="sensorData">-</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Results</div>
                        <div class="stat-value" id="resultCount">0</div>
                    </div>
                </div>
                <div id="results" class="results"></div>
            </div>
        </div>
    </div>

    <script type="module">
        // ==========================================
        // IMPORTS AND GLOBAL VARIABLES
        // ==========================================

        // Import Overshoot SDK from local node_modules
        import { RealtimeVision } from '@overshoot/sdk';

        // Vision and Arduino connection variables
        let vision = null;
        let arduinoWs = null;
        let arduinoConnected = false;

        // State machine variables
        let currentState = 0; // 0 = idle, 1-4 = active states
        let currentPhase = 'idle'; // 'rotating' or 'moving_forward'
        let lastSensorDistance = 999; // Store latest ultrasonic sensor reading
        let resultCount = 0;

        // Distance threshold for stopping forward movement (in cm)
        const DISTANCE_THRESHOLD = 30;

        // ==========================================
        // STATE DEFINITIONS
        // ==========================================

        // Define the 4 states with their target objects
        const STATES = {
            1: {
                name: "State 1: Find Person",
                target: "person's shoes",
                emoji: "ðŸ‘Ÿ",
                prompt: "If person's shoes or feet are not visible in the frame, return 'A'. If person's shoes are on the left side of the frame, return 'A'. If person's shoes are on the right side of the frame, return 'D'. If person's shoes are in the direct center of the frame, return 'W'."
            },
            2: {
                name: "State 2: Find Black Can",
                target: "black soda can",
                emoji: "âš«",
                prompt: "If a black soda can is not visible in the frame, return 'A'. If the black soda can is on the left side of the frame, return 'A'. If the black soda can is on the right side of the frame, return 'D'. If the black soda can is in the direct center of the frame, return 'W'."
            },
            3: {
                name: "State 3: Find Purple Can",
                target: "purple soda can",
                emoji: "ðŸŸ£",
                prompt: "If a purple soda can is not visible in the frame, return 'A'. If the purple soda can is on the left side of the frame, return 'A'. If the purple soda can is on the right side of the frame, return 'D'. If the purple soda can is in the direct center of the frame, return 'W'."
            },
            4: {
                name: "State 4: Find Clear Path",
                target: "clear path",
                emoji: "ðŸ›£ï¸",
                prompt: "If there is no clear path ahead (obstacles blocking the way), return 'A'. If the clear path is on the left side of the frame, return 'A'. If the clear path is on the right side of the frame, return 'D'. If there is a clear path in the direct center of the frame, return 'W'."
            }
        };

        // ==========================================
        // DOM ELEMENT REFERENCES
        // ==========================================

        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('statusDiv');
        const videoPreview = document.getElementById('videoPreview');
        const results = document.getElementById('results');
        const resultCountDiv = document.getElementById('resultCount');
        const apiKeyInput = document.getElementById('apiKey');
        const sensorDataDiv = document.getElementById('sensorData');

        // State info display elements
        const stateTitle = document.getElementById('stateTitle');
        const stateTarget = document.getElementById('stateTarget');
        const stateAction = document.getElementById('stateAction');
        const statePhase = document.getElementById('statePhase');
        const currentStateNum = document.getElementById('currentStateNum');

        // ==========================================
        // ARDUINO WEBSOCKET CONNECTION
        // ==========================================

        // Connect to Arduino WebSocket server for motor control and sensor data
        function connectArduino() {
            try {
                arduinoWs = new WebSocket('ws://localhost:8080');

                arduinoWs.onopen = () => {
                    console.log('âœ… Connected to Arduino server');
                    arduinoConnected = true;
                };

                arduinoWs.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === 'connected') {
                        console.log('Arduino server:', data.message);
                        arduinoConnected = data.arduinoConnected;
                    }
                    else if (data.type === 'commandResult') {
                        console.log(`Command ${data.command} sent:`, data.success);
                    }
                    else if (data.type === 'status') {
                        console.log('Arduino status:', data.message);
                    }
                    else if (data.type === 'sensorData') {
                        // Update sensor data display and store the value
                        const distance = parseFloat(data.data);
                        // console.log(distance);
                        if (!isNaN(distance)) {
                            lastSensorDistance = distance;
                            sensorDataDiv.textContent = distance.toFixed(1);

                            // Check if we need to transition from moving forward to next state
                            checkDistanceThreshold();
                        }
                        // console.log('ðŸ“ Sensor:', data.data);
                    }
                };

                arduinoWs.onerror = (error) => {
                    console.error('Arduino WebSocket error:', error);
                    arduinoConnected = false;
                };

                arduinoWs.onclose = () => {
                    console.log('âš ï¸ Disconnected from Arduino server');
                    arduinoConnected = false;
                    // Try to reconnect after 3 seconds
                    setTimeout(connectArduino, 3000);
                };
            } catch (error) {
                console.error('Failed to connect to Arduino server:', error);
            }
        }

        // ==========================================
        // ARDUINO COMMAND FUNCTIONS
        // ==========================================

        // Send command to Arduino via WebSocket
        function sendArduinoCommand(command) {
            if (arduinoWs && arduinoWs.readyState === WebSocket.OPEN) {
                arduinoWs.send(JSON.stringify({ type: 'command', command }));
                return true;
            } else {
                console.warn('Arduino not connected');
                return false;
            }
        }

        // ==========================================
        // STATE MACHINE FUNCTIONS
        // ==========================================

        // Update the UI to show current state information
        function updateStateDisplay() {
            if (currentState === 0) {
                // Idle state
                stateTitle.textContent = 'âšª Waiting to Start';
                stateTarget.textContent = 'Target: None';
                stateAction.textContent = 'Action: Idle';
                statePhase.textContent = 'Phase: None';
                currentStateNum.textContent = '-';
            } else if (currentState >= 1 && currentState <= 4) {
                // Active state
                const state = STATES[currentState];
                stateTitle.textContent = `${state.emoji} ${state.name}`;
                stateTarget.textContent = `Target: ${state.target}`;

                if (currentPhase === 'rotating') {
                    stateAction.textContent = 'ðŸ”„ Action: Rotating to center target';
                    statePhase.textContent = 'Phase: ROTATION';
                } else if (currentPhase === 'moving_forward') {
                    stateAction.textContent = 'â¬†ï¸ Action: Moving forward to target';
                    statePhase.textContent = 'Phase: APPROACH';
                }

                currentStateNum.textContent = currentState;
            } else if (currentState === 5) {
                // Completed all states
                stateTitle.textContent = 'âœ… Mission Complete!';
                stateTarget.textContent = 'Target: All objectives reached';
                stateAction.textContent = 'Action: Stopped';
                statePhase.textContent = 'Phase: COMPLETE';
                currentStateNum.textContent = 'âœ“';
            }
        }

        // Transition to the next state
        function transitionToNextState() {
            // Stop any current movement
            sendArduinoCommand('X');

            // Move to next state
            currentState++;

            if (currentState > 4) {
                // All states completed
                console.log('ðŸŽ‰ All states completed! Mission accomplished.');
                addLogMessage('ðŸŽ‰ MISSION COMPLETE! All objectives reached.');
                updateStateDisplay();
                stopStream();
                return;
            }

            // Start new state in rotating phase
            currentPhase = 'rotating';
            console.log(`\nðŸ”„ Transitioning to State ${currentState}: ${STATES[currentState].name}`);
            addLogMessage(`ðŸ”„ Transitioning to ${STATES[currentState].name}`);

            // Update UI
            updateStateDisplay();

            // Restart vision with new prompt
            restartVisionWithNewPrompt();
        }

        // Check if distance threshold is reached (for moving forward phase)
        function checkDistanceThreshold() {
            // Only check if we're in moving_forward phase
            if (currentPhase === 'moving_forward' && currentState >= 1 && currentState <= 4) {
                if (lastSensorDistance < DISTANCE_THRESHOLD) {
                    console.log(`âœ… Reached target! Distance: ${lastSensorDistance}cm < ${DISTANCE_THRESHOLD}cm threshold`);
                    addLogMessage(`âœ… Target reached at ${lastSensorDistance.toFixed(1)}cm`);

                    // Transition to next state
                    transitionToNextState();
                }
            }
        }

        // Restart vision stream with updated prompt for current state
        async function restartVisionWithNewPrompt() {
            if (!vision) return;

            try {
                // Get current state prompt
                const prompt = STATES[currentState].prompt;

                // Update the prompt without stopping/restarting the vision stream
                console.log(`ðŸ”„ Updating prompt for ${STATES[currentState].name}`);
                await vision.updatePrompt(prompt);

                console.log(`âœ… Prompt updated successfully for ${STATES[currentState].name}`);

            } catch (error) {
                console.error('Failed to update prompt:', error);
            }
        }

        // ==========================================
        // VISION RESULT PROCESSING
        // ==========================================

        // Handle results from Overshoot Vision API
        function handleVisionResult(result) {
            resultCount++;
            resultCountDiv.textContent = resultCount;

            // Parse the command from the result
            const command = parseMovementCommand(result.result);

            // Log the result
            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-item';

            let commandIndicator = '';
            if (command) {
                const directions = {
                    'W': 'ðŸ”¼ FORWARD',
                    'A': 'â—€ï¸ LEFT',
                    'D': 'â–¶ï¸ RIGHT',
                    'X': 'â¹ï¸ STOP'
                };

                // Send command to Arduino
                if (sendArduinoCommand(command)) {
                    commandIndicator = `<div style="margin-top: 8px; padding: 8px; background: #d1fae5; border-radius: 4px; color: #065f46; font-weight: 600;">
                        ðŸ¤– Command: ${directions[command]}
                    </div>`;
                    console.log(`ðŸ¤– Sent: ${command} (${directions[command]})`);

                    // Check if we should transition from rotating to moving forward
                    if (command === 'W' && currentPhase === 'rotating') {
                        console.log('âœ… Target centered! Switching to forward movement.');
                        addLogMessage('âœ… Target centered - Approaching...');
                        currentPhase = 'moving_forward';
                        updateStateDisplay();
                    }
                }
            }

            resultDiv.innerHTML = `
                <div class="result-number">[${resultCount}] State ${currentState} - ${currentPhase.toUpperCase()}</div>
                <div class="result-text">${result.result}</div>
                <div class="result-latency">Latency: ${result.total_latency_ms.toFixed(1)}ms | Distance: ${lastSensorDistance.toFixed(1)}cm</div>
                ${commandIndicator}
            `;
            results.insertBefore(resultDiv, results.firstChild);
        }

        // Parse movement command from vision API response
        function parseMovementCommand(text) {
            if (!text) return null;

            const upperText = text.toUpperCase();

            // Check for exact command matches first
            if (upperText.includes('W') || upperText.includes('FORWARD')) {
                return 'W';
            } else if (upperText.includes('A') || upperText.includes('LEFT')) {
                return 'A';
            } else if (upperText.includes('D') || upperText.includes('RIGHT')) {
                return 'D';
            } else if (upperText.includes('X') || upperText.includes('STOP')) {
                return 'X';
            }

            return null;
        }

        // Add a log message to the results display
        function addLogMessage(message) {
            const logDiv = document.createElement('div');
            logDiv.className = 'result-item';
            logDiv.style.borderLeft = '4px solid #764ba2';
            logDiv.innerHTML = `
                <div class="result-text" style="font-weight: 600;">${message}</div>
            `;
            results.insertBefore(logDiv, results.firstChild);
        }

        // ==========================================
        // UI UPDATE FUNCTIONS
        // ==========================================

        // Update status bar
        function updateStatus(text, state) {
            statusDiv.textContent = text;
            statusDiv.className = `status ${state}`;
        }

        // ==========================================
        // MAIN CONTROL FUNCTIONS
        // ==========================================

        // Start the autonomous navigation sequence
        async function startStream() {
            const apiKey = apiKeyInput.value.trim();

            if (!apiKey) {
                alert('Please enter your Overshoot API key');
                return;
            }

            if (!arduinoConnected) {
                alert('Arduino not connected! Please start the arduino-server first.');
                return;
            }

            try {
                updateStatus('ðŸ”„ Checking camera permissions...', 'starting');
                startBtn.disabled = true;
                stopBtn.disabled = false;
                resultCount = 0;
                resultCountDiv.textContent = '0';
                results.innerHTML = '';

                // Test camera access with native getUserMedia
                let testStream;
                try {
                    testStream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: false
                    });

                    // Show test stream in video preview
                    videoPreview.srcObject = testStream;
                    updateStatus('âœ… Camera permissions granted - Starting navigation...', 'starting');

                    // Stop test stream before starting Overshoot
                    testStream.getTracks().forEach(track => track.stop());
                    videoPreview.srcObject = null;

                } catch (permError) {
                    console.error('Camera permission error:', permError);
                    let errorMsg = 'Camera access denied';
                    if (permError.name === 'NotAllowedError') {
                        errorMsg = 'Camera permission denied. Please allow camera access and try again.';
                    } else if (permError.name === 'NotFoundError') {
                        errorMsg = 'No camera found. Please connect a camera and try again.';
                    } else if (permError.name === 'NotReadableError') {
                        errorMsg = 'Camera is already in use by another application.';
                    }
                    throw new Error(errorMsg);
                }

                // Initialize state machine - start with State 1
                currentState = 1;
                currentPhase = 'rotating';
                lastSensorDistance = 999;

                console.log('ðŸš€ Starting autonomous navigation sequence');
                addLogMessage('ðŸš€ Starting autonomous navigation - 4 State Mission');

                // Update UI
                updateStateDisplay();

                // Get prompt for first state
                const prompt = STATES[1].prompt;
                console.log('State 1 Prompt:', prompt);

                // Start the Overshoot vision stream
                vision = new RealtimeVision({
                    apiUrl: 'https://cluster1.overshoot.ai/api/v0.2',
                    apiKey: apiKey,
                    prompt: prompt,
                    source: { type: 'camera', cameraFacing: 'user' },
                    iceServers: [{ urls: "turn:34.63.114.235:3478", username: "1769538895:c66a907c-61f4-4ec2-93a6-9d6b932776bb", credential: "Fu9L4CwyYZvsOLc+23psVAo3i/Y=", }],
                    onResult: (result) => {
                        handleVisionResult(result);
                    },
                    onError: (error) => {
                        console.error('Vision Error:', error);
                        updateStatus(`âŒ Error: ${error.message}`, 'error');
                    },
                    debug: false,
                });

                await vision.start();

                // Attach video preview from Overshoot stream
                const stream = vision.getMediaStream();
                if (stream) {
                    videoPreview.srcObject = stream;
                }

                updateStatus('âœ… Navigation active - Autonomous mode', 'active');
                console.log('âœ… Vision stream started successfully');

            } catch (error) {
                console.error('Failed to start:', error);
                updateStatus(`âŒ Failed: ${error.message}`, 'error');
                startBtn.disabled = false;
                stopBtn.disabled = true;
                currentState = 0;
                updateStateDisplay();
            }
        }

        // Stop the navigation sequence
        async function stopStream() {
            console.log('ðŸ›‘ Stopping navigation...');

            // Stop Arduino motors
            sendArduinoCommand('X');

            // Stop vision stream
            if (vision) {
                try {
                    await vision.stop();
                    updateStatus('ðŸ›‘ Navigation stopped', 'idle');
                } catch (error) {
                    console.error('Stop error:', error);
                }
                vision = null;
            }

            // Stop video preview
            if (videoPreview.srcObject) {
                videoPreview.srcObject.getTracks().forEach(track => track.stop());
                videoPreview.srcObject = null;
            }

            // Reset state
            currentState = 0;
            currentPhase = 'idle';
            updateStateDisplay();

            startBtn.disabled = false;
            stopBtn.disabled = true;
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================

        startBtn.addEventListener('click', startStream);
        stopBtn.addEventListener('click', stopStream);

        // Load API key from localStorage if available
        const savedApiKey = localStorage.getItem('overshoot_api_key');
        if (savedApiKey) {
            apiKeyInput.value = savedApiKey;
        }

        // Save API key to localStorage when changed
        apiKeyInput.addEventListener('change', () => {
            localStorage.setItem('overshoot_api_key', apiKeyInput.value);
        });

        // ==========================================
        // INITIALIZATION
        // ==========================================

        // Connect to Arduino server on page load
        connectArduino();

        // Initialize display
        updateStateDisplay();
    </script>
</body>

</html>